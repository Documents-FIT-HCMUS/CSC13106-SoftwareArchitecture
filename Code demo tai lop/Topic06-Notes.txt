Polymorphism
Metamorphism

State

Optimize Code

(1)
Trong điều kiện AND
	điều kiện nào dễ SAI thì để trước


if (A && B)

for (int i=2; i<1000000000; i++)
	if ((i % 2 == 0)&& IsPrime(i))
		..........................;


(2) 
Trong điều kiện OR
	điều kiện nào dễ ĐÚNG thì để trước


(3)
Những gì KHÔNG liên quan biến đếm thì đưa ra bên ngoài vòng lặp

for (int i=0; i< S.length(); i++)
{
}

int n = S.length();
for (int i=0; i< n; i++)
{
}


for (int i=0; i< S.length(); i++)
{
	S[i] = i*5 + a*b/c+d;
}

int temp;
temp =a*b/c+d;

for (int i=0; i< S.length(); i++)
{
	S[i] = i*5 + temp;
}



4) Khai báo mảng hằng số nếu cần dùng nhiều lần

sin (i*2pi/n)

S[i] = sin(i*2pi/n)


5) Biến phép nhân thành phép cộng

for (int i=0; i<n; i++)
	A[i] = 3*i+5;




A[0] = 5;

//A[i+1] - A[i] = 3;

for (int i=1; i<n; i++)
	A[i] = A[i-1]+3;


6) Biến phép lũy thừa thành phép nhân rồi phép cộng
for (int i=0; i<n; i++)
	A[i] = 3*i*i +5*i -2;



A[i+1] - A[i] = 3*(i+1)^2 + 5*(i+1) -2 -
			  (3*i^2 + 5*i -2 )
		     = 6i +8
B[i] = 6i

A[0] = -2;
B[0] = 0;
for (int i=1; i<n; i++)
{
	A[i] = A[i-1] + B[i-1];
	B[i] = B[i-1] + 6;
}



7) unroll loop

8) chỉ viết 1 hàm, không gọi hàm/thủ tục nào khác

9) thay class bằng struct và dùng con trỏ hàm

10) khử phụ thuộc (dependency) giữa các công thức trong vòng lặp














